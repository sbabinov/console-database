# 1. Система команд
## Список команд
1) `tables` - вывести информацию о текущих таблицах
2) `load` - подгрузить в программу таблицу из заданного файла
3) `create` – создать пустую таблицу
4) `insert` – внести новую строку в таблицу
5) `select` – выбрать строку из таблицы по условию
6) `update` – обновить значение в строке по id
7) `delete` – удалить строки по условию
8) `clear` – очистить таблицу
9) `save` – записать таблицу в файл
10) `close` – закрыть таблицу

## `tables`
> Вывести информацию о текущих таблицах.  

Использование:  
    `tables`
Ожидаемый результат:  
    [вывод информации о таблицах], пример:  
    - `users  [ id:PK name:TEXT balance:REAL ]` 

## `load <file> <table_name>`
> Подгрузить в программу таблицу из заданного файла.  

Использование:  
        `load users.txt users`  
Ожидаемый результат:  
        - если файла не существует: `<ERROR: FILE DOESN'T EXIST>`  
        - если таблица с данным именем уже существует: `<ERROR: TABLE ALREADY EXIST>`  
        - если указано некорректное имя таблицы: `<ERROR: INVALID TABLE NAME>`  
        - если таблицу считать не удалось: `<ERROR: INVALID TABLE>`  
        - если таблица успешно подгружена: `<SUCCESSFULLY LOADED>`

## `create <name> [columns]`
> Создать пустую таблицу с именем <name> и заданными столбцами. (подаются в форме `<name>:<type>`). `name` - название столбца, `type` - тип данных (столбец `id` создается автоматически).  

Использование:  
        `create users name:TEXT balance:INT`  
Ожидаемый результат:  
        - если формат столбцов некорректен (некорректный тип/имя или передан столбец id): `<ERROR: INVALID COLUMNS>`  
        - если таблица уже существует: `<ERROR: TABLE ALREADY EXISTS>`  
        - если имя таблицы некорректно: `<ERROR: INVALID TABLE NAME>`  
        - иначе: `<SUCCESSFULLY CREATED>`  

## `insert <table> [values]` 
> Внести в таблицу с заданным именем `<table>` значения `<values>`, переданные через пробел (создается новая строчка в таблице). При избыточном количестве переданных элементов лишние просто отбрасываются.  

Использование:  
        `insert users admin 1000000`  
Ожидаемый результат:  
        - если вставка прошла успешно: `<SUCCESSFULLY INSERTED>`  
        - если таблицы не существует: `<ERROR: TABLE DOESN'T EXIST>`  
        - если заданы неправильные значения (типы не совпадают с типом столбцов): `<ERROR: INVALID VALUE>`  

## `select <table> <condition>`
> Выбрать из указанной таблицы `<table>` строки с указанным условием (через «=»).  

Использование:  
        `select users name=admin`  
Ожидаемый результат:  
        - если записи найдены, они выводятся построчно в консоль в формате:  
        `[ 1 “user” 1000000 ]`  
        - если записи не найдены, ничего не выводится  
        - если указано некорректное имя столбца: `<ERROR: INVALID COLUMN>`  
        - если передано значение неверного типа: `<ERROR: INVALID VALUE>`  
        - если таблицы не существует: `<ERROR: TABLE DOESN'T EXISTS>`  

## `update <table> <row_id> <column> <new_value>`
> Обновить значение в таблице `<table>` в строке с `id` = `<row_id>` в столбце с именем `<column>` на `<new_value>`.  

Использование:  
        `update users 1 balance 0`  
Ожидаемый результат:  
        - если передан некорректный id: `<ERROR: INVALID ID>`  
        - если указан несуществующий столбец: `<ERROR: INVALID COLUMN>`  
        - если указан столбец id: `<ERROR: CANNOT UPDATE ID FIELD>`  
        - если передан некорректный тип данных: `<ERROD: INVALID VALUE>`  
        - если таблицы не существует: `<ERROR: TABLE DOESN'T EXISTS>`  
        - иначе: `<SUCCESSFULLY UPDATED>`  

## `delete <table> <condition>`
> Удалить строки в таблице `<table>` по выборке `<condition>`  

Использование:  
        `delete users id=1`  
Ожидаемый результат:  
        - если удаление прошло успешно: `<SUCCESSFULLY DELETED>`  
        - если таблицы не существует: `<ERROR: TABLE DOESN'T EXIST>`  
        - если передан некорректный столбец: `<ERROR: INVALID COLUMN>`  
        - если указано значение неверного типа: `<ERROR: INVALID VALUE>`  
        - если строк по выборке нет: `<THERE ARE NOT ROWS WITH SPECIFIED CONDITION>`  

## `clear <table>`
> Очистить таблицу, удалив все данные.  

Использование:  
        `clear users`  
Ожидаемый результат:  
        - если таблицы не существует: `<ERROR: TABLE DOESN’T EXIST>`  
        - иначе: `<SUCCESSFULLY CLEARED>`  

## `save <table> <file>`
> Сохранить таблицу в читаемом виде (по колонкам) в указанном файле.  

Использование:  
        `save users users.tb`  
Ожидаемый результат:  
        - если таблицы не существует: `<ERROR: TABLE DOESN'T EXISTS>`  
        - иначе: `<SUCCESSFULLY SAVED>` (таблица успешно сохранена в файл и его можно прочитать текстовым редактором)  

## `close <table>`
> Закрыть таблицу.  

Использование:  
        `close users`  
        `Are you sure you want to close this table (Y/N)?`  
        `> Y`  
Ожидаемый результат:  
        - если Y/y:  
        `<TABLE SUCCESSFULLY CLOSED>`  
        - если N/любой другой текст: продолжение работы  

# 2. Реализованные структуры
## Vector

### Методы интерфейса:
1) специальные (конструктор по умолчанию (O(1)), конструктор с `initializer_list` (O(n)), деструктор (O(n)), конструкторы копирования (O(n)) и перемещения (O(1)); операторы копирующего (O(n)) и перемещающего (O(1)) присваивания);  
2) `оператор []` - O(1);  
3) `size()` - O(1);  
4) `capacity()` - O(1);  
5) `isEmpty()` - O(1);  
6) `swap()` - O(1);  
7) `pushBack()` - в среднем O(1);  
8) `clear()` - O(n)  

## List
> [!NOTE]
> Реализованы константные/неконстантные итераторы.

### Методы интерфейса:
1) специальные (конструктор по умолчанию (O(1)), деструктор (O(n)), конструкторы копирования (O(n)) и перемещения (O(1)); операторы копирующего (O(n)) и перемещающего (O(1)) присваивания);
2) `isEmpty()` – O(1);
3) `size()` – O(1);
4) `front()` – O(1);
5) `back()` – O(1);
6) `pushFront()` – O(1);
7) `pushBack()` – O(1);
8) `popFront()` – O(1);
9) `popBack()` – O(1);
10) `insert()` – O(1);
11) `erase()` – O(1);
12) `swap()` – O(1);
13) `clear()` – O(n);
14) `begin()`, `cbegin()` – O(1);
15) `end()`, `cend()` – O(1)

## HashTable
> [!NOTE]
> Реализованы константные/неконстантные итераторы.

### Методы интерфейса:
1) специальные (конструктор по умолчанию (O(1)), конструктор с `initializer_list` (O(n)), деструктор (O(n)), конструкторы копирования (O(n)) и перемещения (O(1)); операторы копирующего (O(n)) и перемещающего (O(1)) присваивания);
2) `оператор []` – O(1);
3) `at()` – O(1);
4) `isEmpty()` – O(1);
5) `size()` – O(1);
6) `bucketCount()` – O(1);
7) `rehash()` – O(n) (O(1),если rehash не произошел;
8) `insert()` – O(1);
9) `erase()` – O(1);
10) `swap()` – O(1);
11) `clear()` – O(n);
12) `find()` – O(1);
13) `begin()`, `cbegin()` – O(1);
14) `end()`, `cend()` – O(1)

> [!NOTE]
> Инкремент и декремент итераторов выполняется за O(1).

### Хранение элементов
![image](https://github.com/user-attachments/assets/b1d96b05-46e1-4242-b294-d8d7c3190811)

### Расширение хэш-таблицы
![image](https://github.com/user-attachments/assets/33320745-b50c-4178-bd65-9b506190ab2c)

### Тесты
![image](https://github.com/user-attachments/assets/4c3730b8-29c7-4568-96b9-5bbfb2db738c)
![image](https://github.com/user-attachments/assets/9681b307-242f-4090-9f5e-42cf85ef905f)
![image](https://github.com/user-attachments/assets/e27f5fbf-75c8-4764-9d82-b9f4edcdfeac)

# 3. База данных
## class Table
> [!NOTE]
> Поддерживаемые типы данных: `INTEGER` (целые), `REAL` (вещественные), `TEXT` (строки). Особый тип данных (`PK` – primary key) является служебным и недоступен для пользователя.

### Закрытые поля класса:
1)  `columns` – данные о колонках этой таблицы (вектор);
2)  `rows` – строки таблицы с данными (двусвязный список);
3)  `rowIters` – словарь на основе хеш-таблицы, хранящий пару id - iterator (id – идентификатор записи в таблице, iterator – итератор на данную запись в rows);
4)  `lastId` – id последней занесенной записи в таблице.

### Методы класса:
1) специальные (конструктор по умолчанию, конструктор с одним параметром, деструктор, конструкторы копирования и перемещения; операторы копирующего и перемещающего присваивания);
2) `isCorrectRow(ряд)` – проверка ряда на корректность;
3) `getColumns()` – получение столбцов;
4) `getRows()` – получение рядов;
5) `getColumnIndex(имя столбца)` – получение индекса столбца по его имени;
6) `readRow(поток)` – считать ряд с потока в таблицу;
7) `printRow(поток, итератор на ряд/ряд)` – вывести заданный ряд в поток;
8) `insert(ряд)` – внести в таблицу новую запись (ряд);
9) `select(имя столбца, значение)` – получить ряды, удовлетворяющие заданному условию;
10) `update(id ряда, имя столбца, новое значение)` – обновить значение в ряде с заданным id в переданном столбце;
11) `del(имя столбца, значение)` – удалить ряды, удовлетворяющие заданному условию;
12) `swap()` – поменять таблицы местами;
13) `clear()` – очистить таблицу

> [!NOTE]
> Пример формата записи таблицы в файл:  
>      `4 COLUMNS: id:PK first_name:TEXT last_name:TEXT balance:REAL`  
>     `[ 1 "Steve" "Jobs" 1.000.000 ]`  
>     `[ 2 "Jeff" "Bezos" 5.000.000 ]`  
>     `[ 3 "Ilon" "Musk" 10.000.000 ]`  
>     `[ 4 "Pavel" "Durov" 500.000 ]`  
> Первая строка – информация о столбцах, следующие – данные таблицы.




 














